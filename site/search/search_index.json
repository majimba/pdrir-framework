{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"The PDRIR Framework","text":"<p>Version 1.1 Authors: Chawana Maseka, Gemini Organization: Arc Synthesis</p>"},{"location":"#what-is-pdrir","title":"What is PDRIR?","text":"<p>PDRIR is a five-phase methodology for turning ideas into functional, well-engineered projects: Problem, Deconstruction, Research, Implementation, and Refinement. It blends principles from Design Thinking, First-Principles Thinking, Systems Thinking, and Agile Development.</p>"},{"location":"#quick-start","title":"Quick start","text":"<ul> <li>Read Core Philosophy to understand the mindset and pillars.</li> <li>Work through the five phases (P \u2192 D \u2192 R \u2192 I \u2192 R).</li> <li>Try the Clip-Keeper follow-along project to practice the loop.</li> </ul>"},{"location":"#methodology-guides","title":"Methodology guides","text":"<ul> <li>Design Thinking</li> <li>First-Principles Thinking</li> <li>Systems Thinking</li> <li>Agile and Lean Development</li> </ul>"},{"location":"#table-of-contents","title":"Table of contents","text":"<ul> <li>01. Core Philosophy</li> <li>02. Phase 1: Problem (The 'Why')</li> <li>03. Phase 2: Deconstruction (The 'What')</li> <li>04. Phase 3: Research (The 'How')</li> <li>05. Phase 4: Implementation (The 'Do')</li> <li>06. Phase 5: Refinement (The 'Iterate')</li> <li>07. Follow-Along Project: Clip-Keeper</li> <li>08. Framework Validation</li> <li>09. Conclusion</li> </ul>"},{"location":"design_thinking/","title":"Design Thinking: A Practical Guide","text":"<p>A concise, human-centered method for understanding users, reframing problems, and iteratively testing solutions.</p>"},{"location":"design_thinking/#what-it-is","title":"What it is","text":"<p>Design Thinking is an iterative approach that prioritizes user needs, rapid learning, and continuous refinement. It balances desirability (user value), feasibility (technical viability), and viability (business sustainability).</p>"},{"location":"design_thinking/#the-five-phases","title":"The Five Phases","text":"<ul> <li>Empathize: Study users in context; interview, observe, collect pain points.</li> <li>Define: Synthesize insights into a sharp problem statement (POV) and success criteria.</li> <li>Ideate: Generate many solutions; defer judgment; explore breadth before depth.</li> <li>Prototype: Build the smallest artifact that tests a key assumption.</li> <li>Test: Put prototypes in front of users; capture signals; refine the POV and design.</li> </ul> <p>Note: Phases are non-linear\u2014expect to loop and revisit earlier steps as you learn.</p>"},{"location":"design_thinking/#how-it-supports-pdrir","title":"How it supports PDRIR","text":"<ul> <li>P (Problem): Primary driver\u2014craft the problem statement and MVP criteria.</li> <li>D (Deconstruction): Clarifies constraints and user truths from research.</li> <li>R (Research): Guides what data to gather from users and how.</li> <li>I (Implementation): Focuses scope on user value first.</li> <li>R (Refinement): Validates improvements with users; close the feedback loop.</li> </ul>"},{"location":"design_thinking/#quick-checklist","title":"Quick checklist","text":"<ul> <li>Have we talked to at least 3 target users? What surprised us?</li> <li>Can we state the problem from the user\u2019s perspective in one sentence?</li> <li>What\u2019s the smallest testable prototype to validate value?</li> <li>What did our last test change about our problem framing?</li> </ul>"},{"location":"design_thinking/#common-pitfalls","title":"Common pitfalls","text":"<ul> <li>Solution-first thinking; skipping user discovery.</li> <li>Over-polishing prototypes; delaying learning.</li> <li>Testing with non-representative users.</li> </ul>"},{"location":"design_thinking/#sources-and-further-reading-add-your-own","title":"Sources and further reading (add your own)","text":"<ul> <li>TODO: Add links, papers, field notes, and interview summaries here.</li> </ul> <p>Back to Home</p>"},{"location":"official_docs/","title":"The PDRIR Framework: Official Documentation (Legacy Stub)","text":"<p>This document has been reorganized into a clearer, chapter-based structure.</p> <ul> <li>Start here: Home / Landing Page</li> </ul> <p>Chapters:</p> <ul> <li>01. Core Philosophy</li> <li>02. Phase 1: Problem</li> <li>03. Phase 2: Deconstruction</li> <li>04. Phase 3: Research</li> <li>05. Phase 4: Implementation</li> <li>06. Phase 5: Refinement</li> <li>07. Follow-Along Project: Clip-Keeper</li> <li>08. Framework Validation</li> <li>09. Conclusion</li> </ul> <p>Methodology guides:</p> <ul> <li>Design Thinking</li> <li>First-Principles Thinking</li> <li>Systems Thinking</li> <li>Agile and Lean Development</li> </ul>"},{"location":"core/01-core-philosophy/","title":"01. Core Philosophy","text":"<p>Back to Home</p> <p>At its heart, the PDRIR framework\u2014which stands for Problem, Deconstruction, Research, Implementation, and Refinement\u2014is about intentional creation. Many aspiring builders get stuck in one of two traps:</p> <ul> <li>The Tutorial Trap: Endlessly following tutorials without ever creating something novel. This teaches syntax but not problem-solving.</li> <li>The Overwhelm Trap: Having an ambitious idea but no clear process to tackle it, leading to paralysis and inaction.</li> </ul> <p>PDRIR provides the structured escape route. It forces a deliberate pause at each stage, ensuring that what you are building and why you are building it are as important as how you build it.</p>"},{"location":"core/01-core-philosophy/#foundational-pillars","title":"Foundational Pillars","text":"<ul> <li>Design Thinking: We start with the human need. Who is this for? What problem does it truly solve? This ensures we build useful things.</li> <li>First-Principles Thinking: We break problems down to their most fundamental, undeniable truths. This is the most direct path to innovation and deep understanding. Instead of asking \"What do other clipboard managers look like?\", we ask \"What must be true to save a piece of text from the clipboard?\"</li> <li>Systems Thinking: We recognize that our project is a system of interconnected parts. The output of one step is the input of the next. This helps us build modular, maintainable, and scalable solutions.</li> <li>Agile &amp; Lean Principles: We build the simplest possible version first (Minimum Viable Product), get it working, and then iterate. This philosophy of \"build-measure-learn\" reduces wasted effort and delivers value quickly.</li> </ul> <p>Next: 02. Phase 1: Problem | Back to Home</p>"},{"location":"core/02-phase-1-problem/","title":"02. Phase 1: Problem (The 'Why')","text":"<p>Back to Home</p> <p>Core Principle: Define the user and their pain point with absolute clarity.</p> <p>This phase is pure Design Thinking. Before touching a line of code, you must become a user-centric designer.</p>"},{"location":"core/02-phase-1-problem/#process","title":"Process","text":"<ul> <li>Identify a Personal Annoyance: The best initial projects solve your own problems.</li> <li>Bad: \"I want to learn about APIs.\"</li> <li>Good: \"I waste 10 minutes every morning checking three different websites for the weather, my top news headlines, and my calendar. I want a single dashboard.\"</li> <li>Write a Formal Problem Statement: Frame it from the user's perspective.</li> <li>\"As a [user type], I am trying to [achieve a goal], but I am frustrated by [obstacle] which causes [negative impact].\"</li> </ul>"},{"location":"core/02-phase-1-problem/#example","title":"Example","text":"<ul> <li>\"As a busy student, I am trying to keep track of useful code snippets and links I find online, but I am frustrated by pasting them into a single messy text file, which causes me to lose track of them or spend too much time searching for what I need.\"</li> </ul>"},{"location":"core/02-phase-1-problem/#mvp-success-criteria","title":"MVP Success Criteria","text":"<p>What is the absolute minimum for this to be considered a \"win\"? This must be a testable outcome.</p> <p>Example MVP:</p> <ul> <li>\"The tool will allow me to: (1) Press a hotkey to save whatever is currently on my clipboard. (2) See a list of all saved items. (3) Click an item from the list to copy it back to my clipboard.\"</li> </ul>"},{"location":"core/02-phase-1-problem/#output","title":"Output","text":"<p>A clear, concise mission document outlining the problem and the minimum success criteria.</p> <p>Prev: 01. Core Philosophy | Next: 03. Phase 2: Deconstruction</p>"},{"location":"core/03-phase-2-deconstruction/","title":"03. Phase 2: Deconstruction (The 'What')","text":"<p>Back to Home</p> <p>Core Principle: Break the problem into its fundamental, verifiable truths.</p> <p>This is where you apply First-Principles Thinking. You are not allowed to think about specific libraries or existing solutions. You must think about the essential truths of your MVP definition.</p>"},{"location":"core/03-phase-2-deconstruction/#process","title":"Process","text":"<p>Let's deconstruct our clipboard manager's MVP using first principles.</p>"},{"location":"core/03-phase-2-deconstruction/#mvp-goal-1-press-a-hotkey-to-save-whatever-is-currently-on-my-clipboard","title":"MVP Goal 1: \"Press a hotkey to save whatever is currently on my clipboard.\"","text":"<ul> <li>Truth 1: The program must be able to run constantly in the background, listening for keyboard input without being the active window.</li> <li>Truth 2: It must be able to detect a specific key combination (a \"hotkey\").</li> <li>Truth 3: When the hotkey is detected, the program must be able to access the computer's clipboard and read its current content.</li> <li>Truth 4: The program needs a place to store the content it reads. A list in memory or a simple file would be the most fundamental storage.</li> </ul>"},{"location":"core/03-phase-2-deconstruction/#mvp-goal-2-see-a-list-of-all-saved-items","title":"MVP Goal 2: \"See a list of all saved items.\"","text":"<ul> <li>Truth 5: The program needs a user interface (UI) to display the stored items. The most fundamental UI is text printed in the console. A slightly more advanced one is a simple graphical window.</li> <li>Truth 6: The UI must be able to be opened, perhaps by clicking an icon or using another hotkey.</li> </ul>"},{"location":"core/03-phase-2-deconstruction/#mvp-goal-3-click-an-item-from-the-list-to-copy-it-back-to-my-clipboard","title":"MVP Goal 3: \"Click an item from the list to copy it back to my clipboard.\"","text":"<ul> <li>Truth 7: The UI must be interactive. The user needs to be able to select a specific item from the list.</li> <li>Truth 8: Upon selection, the program must be able to write the content of the selected item back to the computer's clipboard.</li> </ul>"},{"location":"core/03-phase-2-deconstruction/#output","title":"Output","text":"<p>A numbered list of the fundamental technical challenges you need to solve. You have transformed one large problem into eight smaller, distinct, and highly searchable mini-problems.</p> <p>Prev: 02. Phase 1: Problem | Next: 04. Phase 3: Research | Back to Home</p>"},{"location":"core/04-phase-3-research/","title":"04. Phase 3: Research (The 'How')","text":"<p>Back to Home</p> <p>Core Principle: Find the tools to solve each deconstructed truth, one at a time.</p> <p>Armed with your list from Phase 2, you can now perform surgical, targeted research. You are no longer \"looking for ideas\"; you are \"looking for tools.\"</p>"},{"location":"core/04-phase-3-research/#process","title":"Process","text":"<p>For each \"truth\" from Phase 2, find the library or technique to achieve it.</p> <ul> <li>Truth 1 &amp; 2 (Background listener, hotkey):</li> <li>Search Query: \"python run in background listen for keyboard\" -&gt; Libraries like pynput or keyboard.</li> <li>Truth 3 &amp; 8 (Access clipboard):</li> <li>Search Query: \"python copy and paste clipboard\" -&gt; Libraries like pyperclip.</li> <li>Truth 4 (Storage):</li> <li>Search Query: \"python save list to file\" -&gt; Concepts like JSON files or simple text files.</li> <li>Truth 5, 6, 7 (GUI):</li> <li>Search Query: \"python simple graphical user interface\" -&gt; Standard libraries like tkinter or third-party options like PySimpleGUI.</li> </ul>"},{"location":"core/04-phase-3-research/#prototyping-sub-step","title":"Prototyping sub-step","text":"<p>Create a tiny prototype for each mini-problem.</p> <ul> <li>test_hotkey.py: Print \"Hello!\" when pressing Ctrl+Shift+C.</li> <li>test_clipboard.py: Print whatever is on the clipboard.</li> <li>test_gui.py: Display a window with a list of dummy items.</li> </ul> <p>This isolates each problem and confirms you can solve it before you try to connect them (Systems Thinking).</p>"},{"location":"core/04-phase-3-research/#output","title":"Output","text":"<p>A set of small, working prototype scripts, one for each core challenge, and a list of the libraries you will use.</p> <p>Prev: 03. Phase 2: Deconstruction | Next: 05. Phase 4: Implementation | Back to Home</p>"},{"location":"core/05-phase-4-implementation/","title":"05. Phase 4: Implementation (The 'Do')","text":"<p>Back to Home</p> <p>Core Principle: Assemble the prototyped solutions into a single, functioning system that meets the MVP criteria.</p> <p>This is the assembly phase. You're moving from scientist to engineer.</p>"},{"location":"core/05-phase-4-implementation/#process","title":"Process","text":"<ul> <li>Create the Main Project File: clip_keeper.py.</li> <li>Structure with Comments: Copy your \"Truths\" from Phase 2 into your main file as comments. This forms the skeleton of your application.</li> <li>Integrate Prototypes: Bring in the code from your test_*.py files into the relevant sections.</li> <li>Connect the System: This is the most challenging part. It's where you apply Systems Thinking. How does the data flow?</li> <li>The pynput hotkey listener (Truth 1) needs to call a function.</li> <li>That function will use pyperclip to get the data (Truth 3).</li> <li>That data is then added to a list, which is your data model (Truth 4).</li> <li>The tkinter GUI will read from that same list to display the items (Truth 5).</li> <li>A button in the tkinter GUI will trigger a function that takes an item and uses pyperclip to write it back to the clipboard (Truth 8).</li> <li>Focus on \"Working,\" Not \"Perfect\": Do not add features. Do not worry about edge cases. Just make it meet the three MVP success criteria. Does it save? Does it display? Does it copy back? If yes, you are done with this phase.</li> </ul>"},{"location":"core/05-phase-4-implementation/#output","title":"Output","text":"<p>A single script, clip_keeper.py, that successfully functions as a Minimum Viable Product.</p> <p>Prev: 04. Phase 3: Research | Next: 06. Phase 5: Refinement | Back to Home</p>"},{"location":"core/06-phase-5-refinement/","title":"06. Phase 5: Refinement (The 'Iterate')","text":"<p>Back to Home</p> <p>Core Principle: Use your own tool and apply the PDRIR loop again to each new idea or problem.</p> <p>This phase is what separates a one-off script from a real tool. You now become your first user and start the cycle over, but on a smaller scale.</p>"},{"location":"core/06-phase-5-refinement/#process","title":"Process","text":"<p>Use your tool for a day. What annoys you? What could be better? Each answer is a new mini-PDRIR cycle.</p>"},{"location":"core/06-phase-5-refinement/#example-idea-persistence","title":"Example idea: Persistence","text":"<p>\"The list gets cleared every time I close the program. I want it to be persistent.\"</p> <ul> <li>P(roblem): Data is not saved between sessions.</li> <li>D(econstruct): The program must write the list of clips to a file on close. It must read that file on startup.</li> <li>R(esearch): \"python save list to json file\", \"tkinter on window close event\".</li> <li>I(mplement): Add the file-saving and file-loading logic.</li> <li>R(efine): What if the file is corrupted? Add a try...except block.</li> </ul>"},{"location":"core/06-phase-5-refinement/#example-idea-truncated-display","title":"Example idea: Truncated display","text":"<p>\"I can't tell which clip is which. I want to see only the first 30 characters.\"</p> <ul> <li>P(roblem): Long clips make the UI messy.</li> <li>D(econstruct): When displaying the list, each item must be truncated to a fixed length.</li> <li>R(esearch): \"python string slicing\".</li> <li>I(mplement): In your GUI display loop, change item to item[:30] + '...'.</li> <li>R(efine): What if the item is less than 30 characters? The ... is unnecessary. Add an if statement.</li> </ul>"},{"location":"core/06-phase-5-refinement/#output","title":"Output","text":"<p>An improved, more robust, and more feature-rich version (V1.1, V1.2, etc.) of your tool. You are now in a continuous improvement loop.</p> <p>Prev: 05. Phase 4: Implementation | Next: 07. Follow-Along Project: Clip-Keeper | Back to Home</p>"},{"location":"core/07-clip-keeper/","title":"07. Follow-Along Project: Clip-Keeper","text":"<p>Back to Home</p>"},{"location":"core/07-clip-keeper/#project-introduction","title":"Project Introduction","text":"<p>Let's apply this entire framework to build the clipboard manager we've been deconstructing.</p> <p>Project: 'Clip-Keeper'</p>"},{"location":"core/07-clip-keeper/#applying-pdrir-step-by-step","title":"Applying PDRIR Step-by-Step","text":""},{"location":"core/07-clip-keeper/#phase-1-problem","title":"Phase 1: Problem","text":"<p>Problem Statement: \"As a user who frequently reuses text snippets (links, commands, email responses), I need a way to quickly save and retrieve items from my clipboard history without a messy text file, so I can work more efficiently.\"</p> <p>MVP Criteria:</p> <ul> <li>Save current clipboard content with a global hotkey (Ctrl+Alt+C).</li> <li>Display saved clips in a simple GUI, activated by another hotkey (Ctrl+Alt+V).</li> <li>Clicking a clip in the GUI copies it back to the clipboard and closes the GUI.</li> </ul>"},{"location":"core/07-clip-keeper/#phase-2-deconstruction","title":"Phase 2: Deconstruction","text":"<p>(As detailed in earlier chapters, we have 8 fundamental truths to solve.)</p>"},{"location":"core/07-clip-keeper/#phase-3-research","title":"Phase 3: Research","text":"<p>Libraries Chosen:</p> <ul> <li>pynput for global hotkey listening.</li> <li>pyperclip for clipboard access.</li> <li>tkinter for the GUI.</li> <li>json for saving the data to a file.</li> </ul> <p>Prototypes: Create test_pynput.py, test_pyperclip.py, and test_tkinter.py to validate each part works in isolation.</p>"},{"location":"core/07-clip-keeper/#phase-4-implementation-the-code","title":"Phase 4: Implementation (The Code)","text":"<p>Create a clip_keeper.py file. The final code would look conceptually like this (simplified):</p> <pre><code># clip_keeper.py - A simple clipboard manager\nimport tkinter as tk\nfrom pynput import keyboard\nimport pyperclip\nimport json\nimport sys\n\n# --- 1. MODEL: Data Storage &amp; Logic ---\nSAVED_DATA_PATH = \"clipboard_history.json\"\nclipboard_history = []\n\ndef load_data():\n    global clipboard_history\n    try:\n        with open(SAVED_DATA_PATH, 'r') as f:\n            clipboard_history = json.load(f)\n    except FileNotFoundError:\n        clipboard_history = [] # Start fresh if no file\n\ndef save_data():\n    with open(SAVED_DATA_PATH, 'w') as f:\n        json.dump(clipboard_history, f)\n\ndef add_current_clipboard():\n    content = pyperclip.paste()\n    if content and content not in clipboard_history:\n        clipboard_history.insert(0, content) # Add to the top\n        save_data()\n        print(\"Saved to clipboard history.\")\n\n# --- 2. VIEW: The User Interface (Tkinter) ---\napp_window = None\n\ndef show_ui():\n    global app_window\n    if app_window:\n        app_window.destroy() # Close old window if it exists\n\n    app_window = tk.Tk()\n    app_window.title(\"Clip-Keeper\")\n    app_window.attributes(\"-topmost\", True) # Keep window on top\n\n    # Add items to a listbox\n    listbox = tk.Listbox(app_window)\n    for item in clipboard_history:\n        # Show a truncated version for readability\n        display_text = (item[:75] + '...') if len(item) &gt; 75 else item\n        listbox.insert(tk.END, display_text.strip())\n    listbox.pack(padx=10, pady=10, fill=tk.BOTH, expand=True)\n\n    def on_select(event):\n        # Get selected original text from the main list\n        selected_indices = listbox.curselection()\n        if selected_indices:\n            original_text = clipboard_history[selected_indices[0]]\n            pyperclip.copy(original_text)\n            app_window.destroy() # Close on selection\n\n    listbox.bind(\"&lt;&lt;ListboxSelect&gt;&gt;\", on_select)\n    app_window.mainloop()\n\n# --- 3. CONTROLLER: Hotkey Listener (pynput) ---\ndef on_press(key):\n    # This function runs in the background\n    pass # We use on_activate for hotkeys\n\ndef for_canonical(f):\n    # Hotkey helper\n    return lambda k: f(listener.canonical(k))\n\n# Define hotkey actions\nhotkey_actions = {\n    '&lt;ctrl&gt;+&lt;alt&gt;+c': add_current_clipboard,\n    '&lt;ctrl&gt;+&lt;alt&gt;+v': show_ui,\n}\n\n# Create the listener\n# The listener runs in a separate thread\nprint(\"Clip-Keeper is running in the background.\")\nprint(\"Press Ctrl+Alt+C to save clipboard.\")\nprint(\"Press Ctrl+Alt+V to view history.\")\n\nload_data() # Load history on startup\nwith keyboard.GlobalHotKeys(hotkey_actions) as listener:\n    listener.join()\n</code></pre>"},{"location":"core/07-clip-keeper/#phase-5-refinement","title":"Phase 5: Refinement","text":"<p>Problem: The UI is basic. I want to be able to search my clips.</p> <p>New PDRIR cycle:</p> <ul> <li>P(roblem): Can't find old clips easily.</li> <li>D(econstruct): Need an input box in the UI. Need to filter the displayed list based on the input box text.</li> <li>R(esearch): \"tkinter entry widget\", \"tkinter filter listbox\".</li> <li>I(mplement): Add the tk.Entry widget and a function that runs on keypress to rebuild the listbox content.</li> <li>R(efine): Search should be case-insensitive. Use .lower() on both the search term and the clip content.</li> </ul> <p>Prev: 06. Phase 5: Refinement | Next: 08. Framework Validation | Back to Home</p>"},{"location":"core/08-framework-validation/","title":"08. Framework Validation: Applying PDRIR to Itself","text":"<p>Back to Home</p>"},{"location":"core/08-framework-validation/#phase-1-problem-validation","title":"Phase 1: Problem (Validation)","text":"<p>Problem Statement: \"As an aspiring developer, I am trying to build useful projects, but I am frustrated by a lack of clear process, which causes me to get overwhelmed and abandon my ideas.\"</p> <p>MVP Success Criteria: A framework that provides a step-by-step process from idea to functioning MVP.</p>"},{"location":"core/08-framework-validation/#phase-2-deconstruction-validation","title":"Phase 2: Deconstruction (Validation)","text":"<ul> <li>Truth 1: A user must first understand the problem they are solving (The 'Why').</li> <li>Truth 2: A user must break the problem into its smallest technical parts (The 'What').</li> <li>Truth 3: A user must find the tools to solve each part (The 'How').</li> <li>Truth 4: A user must assemble the solutions into a working whole (The 'Do').</li> <li>Truth 5: A user must have a process for improving the working whole (The 'Iterate').</li> </ul>"},{"location":"core/08-framework-validation/#phase-3-research-validation","title":"Phase 3: Research (Validation)","text":"<p>Search: \"problem solving methodologies\", \"software development lifecycle\", \"how to break down problems\", \"user-centered design\".</p> <p>Results: This research leads directly to the foundational pillars: Design Thinking (Truth 1), First-Principles/Decomposition (Truth 2), Agile/Lean (Truth 4 &amp; 5), and standard research practices (Truth 3).</p>"},{"location":"core/08-framework-validation/#phase-4-implementation-validation","title":"Phase 4: Implementation (Validation)","text":"<p>Assemble the findings into a named, five-stage process: Problem, Deconstruction, Research, Implementation, Refinement. Write the documentation for it.</p>"},{"location":"core/08-framework-validation/#phase-5-refinement-validation","title":"Phase 5: Refinement (Validation)","text":"<p>Problem: The framework is just a theory. It needs a practical example to be credible.</p> <p>New PDRIR Cycle: Use the framework to build a real-world tool (like the 'Clip-Keeper') and document the process as a tutorial within the main documentation. This makes the framework more robust, understandable, and useful.</p> <p>The test is successful. The framework is self-consistent and its creation follows its own logic.</p> <p>Prev: 07. Follow-Along Project: Clip-Keeper | Next: 09. Conclusion | Back to Home</p>"},{"location":"core/09-conclusion/","title":"09. Conclusion","text":"<p>Back to Home</p> <p>The PDRIR Framework is not a rigid set of rules, but a mental scaffold. Its purpose is to build discipline and confidence. By deliberately separating the acts of defining, deconstructing, researching, and building, you replace chaos with order. You learn to trust the process.</p> <p>The ultimate goal is for this framework to become second nature\u2014an automatic, internalized loop that you apply to any challenge, big or small. When it becomes instinct, you will have transitioned from someone who learns to code into someone who solves problems using code. And that is the true measure of a builder.</p> <p>Prev: 08. Framework Validation | Back to Home</p>"},{"location":"guides/agile_development/","title":"Agile and Lean Development: A Practical Guide","text":"<p>Deliver value fast, learn from feedback, and iterate with discipline and focus.</p>"},{"location":"guides/agile_development/#what-it-is","title":"What it is","text":"<p>Agile is a set of values and practices that favor working software, collaboration, and responsiveness to change. Lean emphasizes removing waste and maximizing flow of value. Together, they promote small, testable increments and continuous improvement.</p>"},{"location":"guides/agile_development/#core-practices","title":"Core practices","text":"<ul> <li>Small batches: Ship minimal increments that demonstrate value.</li> <li>Iterations: Timeboxed cycles with clear goals and reviews.</li> <li>Backlog &amp; prioritization: Ruthless focus on highest-impact work.</li> <li>Definition of Done: Shared criteria for completion and quality.</li> <li>Feedback loops: Demos, retrospectives, and metrics to guide change.</li> <li>Technical excellence: Testing, CI, refactoring to keep velocity sustainable.</li> </ul>"},{"location":"guides/agile_development/#how-it-supports-pdrir","title":"How it supports PDRIR","text":"<ul> <li>P (Problem): Keeps the MVP tight and outcome-focused.</li> <li>D (Deconstruction): Splits work into small, independently testable slices.</li> <li>R (Research): Timeboxes spikes; validates options quickly.</li> <li>I (Implementation): Iterative delivery with CI and automation.</li> <li>R (Refinement): Retrospectives and metrics drive continuous improvement.</li> </ul>"},{"location":"guides/agile_development/#quick-checklist","title":"Quick checklist","text":"<ul> <li>What is the smallest slice that delivers observable value?</li> <li>What will we demo at the end of this iteration?</li> <li>What is our Definition of Done (tests, docs, review, deploy)?</li> <li>Which 1\u20132 metrics indicate we\u2019re improving?</li> </ul>"},{"location":"guides/agile_development/#common-pitfalls","title":"Common pitfalls","text":"<ul> <li>Waterfall in disguise (big up-front plans, late demos).</li> <li>Overcommitting; skipping tests and refactoring.</li> <li>Too many WIP items; context switching kills flow.</li> </ul>"},{"location":"guides/agile_development/#sources-and-further-reading-add-your-own","title":"Sources and further reading (add your own)","text":"<ul> <li>TODO: Add links to methodology guides, team working agreements, and metrics.</li> </ul> <p>Back to Home</p>"},{"location":"guides/design_thinking/","title":"Design Thinking: A Practical Guide","text":"<p>A concise, human-centered method for understanding users, reframing problems, and iteratively testing solutions.</p>"},{"location":"guides/design_thinking/#what-it-is","title":"What it is","text":"<p>Design Thinking is an iterative approach that prioritizes user needs, rapid learning, and continuous refinement. It balances desirability (user value), feasibility (technical viability), and viability (business sustainability).</p>"},{"location":"guides/design_thinking/#the-five-phases","title":"The Five Phases","text":"<ul> <li>Empathize: Study users in context; interview, observe, collect pain points.</li> <li>Define: Synthesize insights into a sharp problem statement (POV) and success criteria.</li> <li>Ideate: Generate many solutions; defer judgment; explore breadth before depth.</li> <li>Prototype: Build the smallest artifact that tests a key assumption.</li> <li>Test: Put prototypes in front of users; capture signals; refine the POV and design.</li> </ul> <p>Note: Phases are non-linear\u2014expect to loop and revisit earlier steps as you learn.</p>"},{"location":"guides/design_thinking/#how-it-supports-pdrir","title":"How it supports PDRIR","text":"<ul> <li>P (Problem): Primary driver\u2014craft the problem statement and MVP criteria.</li> <li>D (Deconstruction): Clarifies constraints and user truths from research.</li> <li>R (Research): Guides what data to gather from users and how.</li> <li>I (Implementation): Focuses scope on user value first.</li> <li>R (Refinement): Validates improvements with users; close the feedback loop.</li> </ul>"},{"location":"guides/design_thinking/#quick-checklist","title":"Quick checklist","text":"<ul> <li>Have we talked to at least 3 target users? What surprised us?</li> <li>Can we state the problem from the user\u2019s perspective in one sentence?</li> <li>What\u2019s the smallest testable prototype to validate value?</li> <li>What did our last test change about our problem framing?</li> </ul>"},{"location":"guides/design_thinking/#common-pitfalls","title":"Common pitfalls","text":"<ul> <li>Solution-first thinking; skipping user discovery.</li> <li>Over-polishing prototypes; delaying learning.</li> <li>Testing with non-representative users.</li> </ul>"},{"location":"guides/design_thinking/#sources-and-further-reading-add-your-own","title":"Sources and further reading (add your own)","text":"<ul> <li>TODO: Add links, papers, field notes, and interview summaries here.</li> </ul> <p>Back to Home</p>"},{"location":"guides/first_principles_thinking/","title":"First-Principles Thinking: A Practical Guide","text":"<p>Reason from the ground up by reducing problems to fundamental truths and rebuilding solutions without inherited assumptions.</p>"},{"location":"guides/first_principles_thinking/#what-it-is","title":"What it is","text":"<p>First-principles thinking separates facts (constraints, physics, protocols, invariants) from assumptions (habits, defaults, opinions). You decompose, validate each truth, and reconstruct the simplest system that must work under those truths.</p>"},{"location":"guides/first_principles_thinking/#core-steps","title":"Core steps","text":"<ul> <li>Define the goal: What outcome must be achieved, minimally?</li> <li>List fundamentals: What must be true? What are hard constraints? What are invariants?</li> <li>Expose assumptions: What are we taking for granted? How can we falsify them quickly?</li> <li>Model from basics: Sketch the minimal mechanism that satisfies the truths.</li> <li>Recombine: Add only what is necessary; prefer composable primitives.</li> <li>Test cheaply: Prototypes that validate or invalidate the riskiest assumptions first.</li> </ul>"},{"location":"guides/first_principles_thinking/#how-it-supports-pdrir","title":"How it supports PDRIR","text":"<ul> <li>P (Problem): Clarifies the real need vs. the assumed need.</li> <li>D (Deconstruction): Primary driver\u2014enumerate fundamental truths and constraints.</li> <li>R (Research): Targeted search for tools that satisfy identified truths.</li> <li>I (Implementation): Encourages minimal, composable architecture.</li> <li>R (Refinement): Remove accidental complexity; revisit assumptions that failed.</li> </ul>"},{"location":"guides/first_principles_thinking/#quick-checklist","title":"Quick checklist","text":"<ul> <li>Can we state the problem without mentioning a tool or UI?</li> <li>Which 3 constraints would make the solution impossible if wrong?</li> <li>What can we remove without breaking correctness?</li> <li>What is the cheapest test to invalidate our riskiest assumption?</li> </ul>"},{"location":"guides/first_principles_thinking/#common-pitfalls","title":"Common pitfalls","text":"<ul> <li>Confusing popularity with necessity.</li> <li>Skipping falsification; only seeking confirming evidence.</li> <li>Overfitting to the first working prototype.</li> </ul>"},{"location":"guides/first_principles_thinking/#sources-and-further-reading-add-your-own","title":"Sources and further reading (add your own)","text":"<ul> <li>TODO: Add articles, notes, and experiments validating/invalidating assumptions.</li> </ul> <p>Back to Home</p>"},{"location":"guides/systems_thinking/","title":"Systems Thinking: A Practical Guide","text":"<p>Understand and design whole systems by focusing on relationships, flows, and feedback, not just components.</p>"},{"location":"guides/systems_thinking/#what-it-is","title":"What it is","text":"<p>Systems Thinking is a holistic approach that studies how parts interact to produce behavior over time. It emphasizes boundaries, stocks and flows, delays, feedback loops (reinforcing and balancing), and emergent outcomes.</p>"},{"location":"guides/systems_thinking/#core-concepts","title":"Core concepts","text":"<ul> <li>Elements and boundaries: Define what\u2019s inside/outside the system; avoid scope creep.</li> <li>Stocks and flows: Quantities that accumulate (stocks) and the rates that change them (flows).</li> <li>Feedback loops:</li> <li>Reinforcing (R): Amplify change (growth/decline).</li> <li>Balancing (B): Resist change (stability/targets).</li> <li>Delays: Gaps between action and effect; source of oscillations.</li> <li>Leverage points: Small changes that produce large, lasting effects.</li> </ul>"},{"location":"guides/systems_thinking/#how-it-supports-pdrir","title":"How it supports PDRIR","text":"<ul> <li>P (Problem): Sets system boundary and outcome measures.</li> <li>D (Deconstruction): Identifies key stocks, flows, and feedbacks to address.</li> <li>R (Research): Targets tools/techniques that fit the system\u2019s constraints.</li> <li>I (Implementation): Guides data flow, module boundaries, and event handling.</li> <li>R (Refinement): Observes runtime behavior; adjusts loops, thresholds, and delays.</li> </ul>"},{"location":"guides/systems_thinking/#quick-checklist","title":"Quick checklist","text":"<ul> <li>What is the system boundary? Who/what is outside it but influences it?</li> <li>Which variables accumulate? What increases/decreases them?</li> <li>Where are the strongest feedback loops? Are they R or B?</li> <li>What delays could cause overshoot or oscillation?</li> <li>Where are 1\u20132 leverage points for the MVP?</li> </ul>"},{"location":"guides/systems_thinking/#common-pitfalls","title":"Common pitfalls","text":"<ul> <li>Optimizing parts at the expense of the whole.</li> <li>Ignoring delays; misattributing causes to the wrong actions.</li> <li>Overcomplicating models; forgetting parsimony.</li> </ul>"},{"location":"guides/systems_thinking/#sources-and-further-reading-add-your-own","title":"Sources and further reading (add your own)","text":"<ul> <li>TODO: Add diagrams, causal loop maps, and reference links here.</li> </ul> <p>Back to Home</p>"}]}